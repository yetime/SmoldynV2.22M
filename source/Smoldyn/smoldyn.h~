/* Steven Andrews, started 10/22/2001.
 This is the header for the Smoldyn program.  See documentation
 called Smoldyn_doc1.pdf and Smoldyn_doc2.pdf.
 Copyright 2003-2011 by Steven Andrews.  This work is distributed under the terms
 of the Gnu General Public License (GPL). */

#ifndef __smoldyn_h__
#define __smoldyn_h__

#include <time.h>
#include <stdio.h>
#include "opengl2.h"
#include "parse.h"
#include "SimCommand.h"
#include "smoldyn_config.h"			// generated by the ./configure script

/********************************** General *********************************/

#define DIMMAX 3							// maximum system dimensionality
#define VERYCLOSE 1.0e-12			// distance that's safe from round-off error

enum StructCond {SCinit,SClists,SCparams,SCok};

/********************************* Molecules ********************************/

#define MSMAX 5
#define MSMAX1 6
enum MolecState {MSsoln,MSfront,MSback,MSup,MSdown,MSbsoln,MSall,MSnone,MSsome};
enum MolListType {MLTsystem,MLTport,MLTnone};

typedef struct moleculestruct {
	long int serno;							// serial number
	int list;										// destination list number (ll)
	double *pos;								// dim dimensional vector for position [d]
	double *posx;								// dim dimensional vector for old position [d]
	double *via;								// location of last surface interaction [d]
	double *posoffset;					// position offset arising from jumps [d]
	int ident;									// species of molecule; 0 is empty (i)
	enum MolecState mstate;			// physical state of molecule (ms)
	struct boxstruct *box;			// pointer to box which molecule is in
	struct panelstruct *pnl;		// panel that molecule is bound to if any
	} *moleculeptr;

typedef struct molsuperstruct {
	enum StructCond condition;	// structure condition
	struct simstruct *sim;			// simulation structure
	int maxspecies;							// maximum number of species
	int nspecies;								// number of species, including empty mols.
	char **spname;							// names of molecular species
	double **difc;							// diffusion constants [i][ms]
	double **difstep;						// rms diffusion step [i][ms]
	double ***difm;							// diffusion matrix [i][ms][d]
	double ***drift;						// drift vector [i][ms][d]
	double **display;						// display size of molecule [i][ms] 
	double ***color;						// RGB color vector [i][ms]
	int **exist;								// flag for if molecule could exist [i][ms]
	moleculeptr *dead;					// list of dead molecules [m]
	int maxd;										// size of dead molecule list
	int nd;											// total number of molecules in dead list
	int topd;										// index for dead list; above are resurrected
	int maxlist;								// allocated number of live lists
	int nlist;									// number of live lists
	int **listlookup;						// lookup table for live lists [i][ms]
	char **listname;						// names of molecule lists [ll]
	enum MolListType *listtype;	// types of molecule lists [ll]
	moleculeptr **live;					// live molecule lists [ll][m]
	int *maxl;									// size of molecule lists [ll]
	int *nl;										// number of molecules in live lists [ll]
	int *topl;									// live list index; above are reborn [ll]
	int *sortl;									// live list index; above need sorting [ll]
	int *diffuselist;						// 1 if any listed molecs diffuse [ll]
	long int serno;							// serial number for next resurrected molec.
	int ngausstbl;							// number of elements in gausstbl
	double *gausstbl;						// random numbers for diffusion
	int *expand;								// whether species expand with libmzr [i]
	} *molssptr;

/*********************************** Walls **********************************/

typedef struct wallstruct {
	int wdim;										// dimension number of perpendicular to wall
	int side;										// low side of space (0) or high side (1)
	double pos;									// position of wall along dim axis
	char type;									// properties of wall
	struct wallstruct *opp; 		// pointer to opposite wall
	} *wallptr;

/********************************* Reactions ********************************/

#define MAXORDER 3
#define MAXPRODUCT 16
enum RevParam {RPnone,RPirrev,RPconfspread,RPbounce,RPpgem,RPpgemmax,RPpgemmaxw,RPratio,RPunbindrad,RPpgem2,RPpgemmax2,RPratio2,RPoffset,RPfixed};

typedef struct rxnstruct {
	struct rxnsuperstruct *rxnss;	// pointer to superstructure
	char *rname;								// pointer to name of reaction
	int *rctident;							// list of reactant identities [rct]
	enum MolecState *rctstate;	// list of reactant states [rct]
	int *permit;								// permissions for reactant states [ms]
	int nprod;									// number of products
	int *prdident;							// list of product identities [prd]
	enum MolecState *prdstate;	// list of product states [prd]
	double rate;								// requested reaction rate
	//double bindrad2;						// squared binding radius, if appropriate
	double *bindrad2;						// @Christine squared binding radii 
	double prob;								// reaction probability
	double tau;									// characteristic reaction time
	enum RevParam rparamt;			// type of parameter in rpar
	double rparam;							// parameter for reaction of products
	//double unbindrad;						// unbinding radius, if appropriate
	double *unbindrad;		//unbindradius accounting for surfaces
	double **prdpos;						// product position vectors [prd][d]
	struct compartstruct *cmpt;	// compartment reaction occurs in, or NULL
	struct surfacestruct *srf;	// surface reaction on, or NULL
	} *rxnptr;

typedef struct rxnsuperstruct {
	enum StructCond condition;	// structure condition
	struct simstruct *sim;			// simulation structure
	int order;									// order of reactions listed: 0, 1, or 2
	int maxspecies;							// maximum number of species
	int maxlist;								// copy of maximum number of molecule lists
	int *nrxn;									// number of rxns for each reactant set [i]
	int **table;								// lookup table for reaction numbers [i][j]
	int maxrxn;									// allocated number of reactions
	int totrxn;									// total number of reactions listed
	char **rname;								// names of reactions [r]
	rxnptr *rxn;								// list of reactions [r]
	int *rxnmollist;						// live lists that have reactions [ll]
	} *rxnssptr;

/********************************* Surfaces *********************************/

#define PSMAX 6															// maximum number of panel shapes
enum PanelFace {PFfront,PFback,PFnone,PFboth};
enum PanelShape {PSrect,PStri,PSsph,PScyl,PShemi,PSdisk,PSall,PSnone};
enum SrfAction {SAreflect,SAtrans,SAabsorb,SAjump,SAport,SAmult,SAno,SAnone,SAadsorb,SArevdes,SAirrevdes,SAflip};
enum DrawMode {DMno=0,DMvert=1,DMedge=2,DMve=3,DMface=4,DMvf=5,DMef=6,DMvef=7,DMnone};
enum SMLflag {SMLno=0,SMLdiffuse=1,SMLreact=2,SMLsrfbound=4};

typedef struct surfactionstruct {
	int *srfnewspec;						// surface convert mol. species [ms]
	double *srfrate;						// surface action rate [ms]
	double *srfprob;						// surface action probability [ms]
	double *srfcumprob;					// surface cumulative probability [ms]
	int *srfdatasrc;						// surface data source [ms]
	double *srfrevprob;					// probability of reverse action [ms]
	} *surfactionptr;

typedef struct panelstruct {
	char *pname;								// panel name (reference, not owned)
	enum PanelShape ps;					// panel shape
	struct surfacestruct *srf;	// surface that owns this panel
	int npts;										// number of defining points
	double **point;							// defining points, [number][d]
	double front[DIMMAX];				// front parameters, which depend on the shape
	struct panelstruct *jumpp[2];// panel to jump to, if appropriate [face]
	enum PanelFace jumpf[2];		// face to jump to, if appropriate [face]
	int maxneigh;								// maximum number of neighbor panels
	int nneigh;									// number of neighbor panels
	struct panelstruct **neigh;	// list of neighbor panels [p]
	double *emitterabsorb[2];		// absorption for emitters [face][i]
	} *panelptr;

typedef struct surfacestruct {
	int surface_number; 			//According to surface list in srfss
	char *sname;								// surface name (reference, not owned)
	struct surfacesuperstruct *srfss;	// owning surface superstructure
	enum SrfAction ***action;		// action for molecules [i][ms][face]
	surfactionptr ***actdetails;	// action details [i][ms][face]
	double fcolor[4];						// RGBA color vector for front
	double bcolor[4];						// RGBA color vector for back
	double edgepts;							// thickness of edge for drawing
	unsigned int edgestipple[2];	// edge stippling [factor,pattern]
	enum DrawMode fdrawmode;		// polygon drawing mode for front
	enum DrawMode bdrawmode;		// polygon drawing mode for back
	double fshiny;							// front shininess
	double bshiny;							// back shininess
	int maxpanel[PSMAX];				// allocated number of panels [ps]
	int npanel[PSMAX];					// actual number of panels [ps]
	char **pname[PSMAX];				// names of panels [ps][p]
	panelptr *panels[PSMAX];		// list of panels [ps][p]
	struct portstruct *port[2];	// port, if any, for each face [face]
	double totarea;							// total surface area
	int totpanel;								// total number of panels
	double *areatable;					// cumulative panel areas [pindex]
	panelptr *paneltable;				// sequential list of panels [pindex]
	int *maxemitter[2];					// maximum number of emitters [face][i]
	int *nemitter[2];						// number of emitters [face][i]
	double **emitteramount[2];	// emitter amounts [face][i][emit]
	double ***emitterpos[2];		// emitter positions [face][i][emit][d]
	double **sdifc;			//@Christine Surface specific difusion coefficients [i][ms]
	double **sdifstep;		//@Christine Surface specific difusion coefficients [i][ms]
	 } *surfaceptr;

typedef struct surfacesuperstruct {
	enum StructCond condition;	// structure condition
	struct simstruct *sim;			// simulation structure
	int maxspecies;							// maximum number of molecular species
	int maxsrf;									// maximum number of surfaces
	int nsrf;										// number of surfaces
	double epsilon;							// max deviation of surface-point from surface
	double neighdist;						// neighbor distance value
	char **snames;							// surface names [s]
	surfaceptr *srflist;				// list of surfaces [s]
	int maxmollist;							// number of molecule lists allocated
	int nmollist;								// number of molecule lists used
	enum SMLflag *srfmollist;		// flags for molecule lists to check [ll]
	} *surfacessptr;

/*********************************** Boxes **********************************/

typedef struct boxstruct {
	int *indx;									// dim dimensional index of the box [d]
	int nneigh;									// number of neighbors in list
	int midneigh;								// logical middle of neighbor list
	struct boxstruct **neigh;		// all box neighbors, using sim. accuracy
	int *wpneigh;								// wrapping code of neighbors in list
	int nwall;									// number of walls in box
	wallptr *wlist;							// list of walls that cross the box
	int maxpanel;								// allocated number of panels in box
	int npanel;									// number of surface panels in box
	panelptr *panel;						// list of panels in box
	int *maxmol;								// allocated size of live lists [ll]
	int *nmol;									// number of molecules in live lists [ll]
	moleculeptr **mol;					// lists of live molecules in the box [ll][m]
	} *boxptr;

typedef struct boxsuperstruct {
	enum StructCond condition;	// structure condition
	struct simstruct *sim;			// simulation structure
	int nlist;									// copy of number of molecule lists
	double mpbox;								// requested number of molecules per box
	double boxsize;							// requested box width
	double boxvol;							// actual box volumes
	int nbox;										// total number of boxes
	int *side;									// number of boxes on each side of space
	double *min;								// position vector for low corner of space
	double *size;								// length of each side of a box
	boxptr *blist; 							// actual array of boxes
	} *boxssptr;

/******************************* Compartments *******************************/

enum CmptLogic {CLequal,CLequalnot,CLand,CLor,CLxor,CLandnot,CLornot,CLnone};

typedef struct compartstruct {
	struct compartsuperstruct *cmptss;	// compartment superstructure
	char *cname;								// compart. name (reference, not owned)
	int nsrf;										// number of bounding surfaces
	surfaceptr *surflist;				// list of bounding surfaces [s]
	int npts;										// number of inside-defining points
	double **points;						// list of inside-defining points [k][d]
	int ncmptl;									// number of logic compartments
	struct compartstruct **cmptl;	// list of logic compartments [cl]
	enum CmptLogic *clsym;			// compartment logic symbol [cl]
	double volume;							// volume of compartment
	int maxbox;									// maximum number of boxes in compartment
	int nbox;										// number of boxes inside compartment
	boxptr *boxlist;						// list of boxes inside compartment [b]
	double *boxfrac;						// fraction of box volume that's inside [b]
	double *cumboxvol;					// cumulative cmpt. volume of boxes [b]
	} *compartptr;

typedef struct compartsuperstruct {
	enum StructCond condition;	// structure condition
	struct simstruct *sim;			// simulation structure
	int maxcmpt;								// maximum number of compartments
	int ncmpt;									// actual number of compartments
	char **cnames;							// compartment names
	compartptr *cmptlist;				// list of compartments
	} *compartssptr;

/*********************************** Ports **********************************/

typedef struct portstruct {
	char *portname;							// port name (reference, not owned)
	surfaceptr srf;							// porting surface (ref.)
	enum PanelFace face;				// active face of porting surface
	int llport;									// live list number for buffer
	} *portptr;

typedef struct portsuperstruct {
	enum StructCond condition;	// structure condition
	struct simstruct *sim;			// simulation structure
	int maxport;								// maximum number of ports
	int nport;									// actual number of ports
	char **portnames;						// port names
	portptr *portlist;					// list of ports
	} *portssptr;

/******************************* Moleculizer ********************************/

typedef struct mzrsuperstruct {
	enum StructCond condition;				// structure condition
	struct simstruct *sim;						// simulation structure
	struct moleculizer_handle *mzr;		// moleculizer object
	int ruleschars;										// number of characters in rules
	char *rules;											// input rules file
	int maxstreams;										// allocated number of species streams
	int nstreams;											// actual number of species streams
	char **streamname;								// names of species streams [strm]
	double **displaysize;							// display sizes for streams [strm][ms]
	double ***color;									// colors for streams [strm][ms][c]
	double **strmdifc;								// diff. coeff. for streams [strm][ms]
	int maxNetworkSpecies;						// maximum expansion size of network
	int maxnamehash;									// allocated size of name hash
	int nnamehash;										// actual size of name hash
	char **tagname;										// hash list of mzr tagged names
	char **smolname;									// hash list of Smoldyn names
	int maxrxnhash;										// allocated size of reaction hash
	int nrxnhash;											// actual size of reaction hash
	char **mzrrxn;										// hash list of mzr reaction names
	char **smolrxn;										// hash list of Smoldyn reaction names
	int maxspecies;										// allocated size of species list
	enum MolecState *defaultstate;		// default state for each species [i]
	int refspecies;										// species for diffusion coeff. reference
	double refmass;										// mass of reference species
	double refdifc[MSMAX];						// diffusion coefficients of ref. species
	int expandall;										// flag for full expansion at initialize
	} *mzrssptr;

/******************************** Threading ********************************/
//???????????? nothing in this section is documented yet
#define BASE_STACK_SIZE sizeof(int) * 16;

typedef struct stackstruct { // Used internally by threads for input/output
	void* stack_data;
	size_t current_size;
	size_t max_size;
	} stack;

typedef void* thread_t;

typedef struct threadstruct { // All the data needed to execute a thread.
	thread_t thread_id;
	stack* input_stack;
	stack* output_stack;
	} *threadptr;

typedef struct threadingsuperstruct { // Master structure that contains all the information for all threads.  
	threadptr* thread;
	int nthreads;
	} *threadssptr;

/********************************* Graphics ********************************/

#define MAXLIGHTS 8						// must be ≤ GL_MAX_LIGHTS
enum LightParam {LPambient,LPdiffuse,LPspecular,LPposition,LPon,LPoff,LPauto,LPnone};

typedef struct graphicssuperstruct {
	int graphics;								// graphics: 0=none, 1=opengl, 2=good opengl
	int graphicit;							// number of time steps per graphics update
	unsigned int graphicdelay;	// minimum delay (in ms) for graphics updates
	int tiffit;									// number of time steps per tiff save
	double framepts;						// thickness of frame for graphics
	double gridpts;							// thickness of virtual box grid for graphics
	double framecolor[4];				// frame color [c]
	double gridcolor[4];				// grid color [c]
	double backcolor[4];				// background color [c]
	enum LightParam roomstate;	// on, off, or auto (on)
	GLfloat ambiroom[4];				// global ambient light [c]
	enum LightParam lightstate[MAXLIGHTS];	// on, off, or auto (off) [lt]
	GLfloat ambilight[MAXLIGHTS][4];	// ambient light color [lt][c]
	GLfloat difflight[MAXLIGHTS][4]; // diffuse light color [lt][c]
	GLfloat speclight[MAXLIGHTS][4]; // specular light color [lt][c]
	GLfloat lightpos[MAXLIGHTS][3];	// light positions [lt][d]
	} *graphicsssptr;

/******************************** Simulation *******************************/

#define ETMAX 10
enum SmolStruct {SSmolec,SSwall,SSrxn,SSsurf,SSbox,SScmpt,SSport,SScmd,SSmzr,SSsim,SScheck,SSall,SSnone};
enum EventType {ETwall,ETsurf,ETdesorb,ETrxn0,ETrxn1,ETrxn2intra,ETrxn2inter,ETrxn2wrap,ETimport,ETexport};

typedef int (*diffusefnptr)(struct simstruct *);
typedef int (*surfaceboundfnptr)(struct simstruct *,int);
typedef int (*surfacecollisionsfnptr)(struct simstruct *,int,int);
typedef int (*assignmols2boxesfnptr)(struct simstruct *,int,int);
typedef int (*zeroreactfnptr)(struct simstruct *);
typedef int (*unimolreactfnptr)(struct simstruct *);
typedef int (*bimolreactfnptr)(struct simstruct *,int);
typedef int (*checkwallsfnptr)(struct simstruct *,int,int,boxptr);

typedef struct simstruct {
	enum StructCond condition;	// structure condition
	char *filepath;							// configuration file path
	char *filename;							// configuration file name
	char *flags;								// command-line options from user
	time_t clockstt;						// clock starting time of simulation
	double elapsedtime;					// elapsed time of simulation
	long int randseed;					// random number generator seed
	int eventcount[ETMAX];			// counter for simulation events
	int dim;										// dimensionality of space.
	double accur;								// accuracy, on scale from 0 to 10
	double time;								// current time in simulation
	double tmin;								// simulation start time
	double tmax;								// simulation end time
	double dt;									// simulation time step
	rxnssptr rxnss[MAXORDER];		// reaction superstructures
	molssptr mols;							// molecule superstructure
	wallptr *wlist;							// list of walls
	surfacessptr srfss;					// surface superstructure
	boxssptr boxs;							// box superstructure
	compartssptr cmptss;				// compartment superstructure
	portssptr portss;						// port superstructure
	mzrssptr mzrss;							// network generation rule superstructure
	cmdssptr cmds;							// command superstructure
	graphicsssptr graphss;			// graphics superstructure
	threadssptr threads;				// pthreads superstructure
	diffusefnptr diffusefn;											// function for molecule diffusion
	surfaceboundfnptr surfaceboundfn;						// function for surface-bound molecules
	surfacecollisionsfnptr surfacecollisionsfn; // function for surface collisons
	assignmols2boxesfnptr assignmols2boxesfn;		// function that assigns molecs to boxes
	zeroreactfnptr zeroreactfn;									// function for zero order reactions
	unimolreactfnptr unimolreactfn;							// function for first order reactions
	bimolreactfnptr bimolreactfn;								// function for second order reactions
	checkwallsfnptr checkwallsfn;								// function for molecule collisions with walls
	} *simptr;

/********************************* Molecules *******************************/

// enumerated type functions
enum MolecState molstring2ms(char *string);
char *molms2string(enum MolecState ms,char *string);
enum MolListType molstring2mlt(char *string);
char *molmlt2string(enum MolListType mlt,char *string);

// low level utilities
int readmolname(simptr sim,char *str,enum MolecState *msptr);
char *molpos2string(simptr sim,moleculeptr mptr,char *string);
void molchangeident(simptr sim,moleculeptr mptr,int ll,int m,int i,enum MolecState ms,panelptr pnl);
int molssetgausstable(molssptr mols,int size);
void molsetdifc(simptr sim,int ident,enum MolecState ms,double difc);
int molsetdifm(simptr sim,int ident,enum MolecState ms,double *difm);
int molsetdrift(simptr sim,int ident,enum MolecState ms,double *drift);
void molsetdisplaysize(simptr sim,int ident,enum MolecState ms,double dsize);
void molsetcolor(simptr sim,int ident,enum MolecState ms,double *color);
void molsetlistlookup(simptr sim,int ident,enum MolecState ms,int ll);
void molsetexist(simptr sim,int ident,enum MolecState ms,int exist);
int molcount(simptr sim,int i,enum MolecState ms,boxptr bptr,int max);
double MolCalcDifcSum(simptr sim,int i1,enum MolecState ms1,int i2,enum MolecState ms2, int surfaceID);

// memory management
moleculeptr molalloc(int dim);
void molfree(moleculeptr mptr);
molssptr molssalloc(int maxspecies);
int mollistalloc(molssptr mols,int maxlist,enum MolListType mlt);
int molexpandlist(molssptr mols,int dim,int ll,int nspaces,int nmolecs);
void molssfree(molssptr mols);

// data structure output
void molssoutput(simptr sim);
void writemols(simptr sim,FILE *fptr);
void writemolecules(simptr sim,FILE *fptr);
int checkmolparams(simptr sim,int *warnptr);

// structure setup
void molsetcondition(molssptr mols,enum StructCond cond,int upgrade);
int addmollist(simptr sim,char *nm,enum MolListType mlt);
int molsetmaxspecies(simptr sim,int max);
int molsetmaxmol(simptr sim,int max);
int moladdspecies(simptr sim,char *nm);
int molsetexpansionflag(simptr sim,int i,int flag);
void molsettimestep(molssptr mols,double dt);
void molcalcparams(molssptr mols,double dt);
int setupmols(simptr sim);

// adding and removing molecules
void molkill(simptr sim,moleculeptr mptr,int ll,int m);
moleculeptr getnextmol(molssptr mols);
moleculeptr newestmol(molssptr mols);
int addmol(simptr sim,int nmol,int ident,double *poslo,double *poshi,int sort);
int addsurfmol(simptr sim,int nmol,int ident,enum MolecState ms,double *pos,panelptr pnl,int surface,enum PanelShape ps,char *pname);
int addcompartmol(simptr sim,int nmol,int ident,compartptr cmpt);
int molgetexport(simptr sim,int ident,enum MolecState ms);
int molputimport(simptr sim,int nmol,int ident,enum MolecState ms,panelptr pnl,enum PanelFace face);
int moldummyporter(simptr sim);

// core simulation functions
int molsort(simptr sim);
int diffuse(simptr sim);
int diffuse_threaded(simptr sim);  // diffuses all molecules -- multithreaded ?????? change
double adjust_difstep(double* pos, molssptr mols, moleculeptr mptr, int dim, int mol_ndx, enum MolecState ms); //helper function for surfaces with different diffusion coefficients for the same molecular species, Christine


/*********************************** Walls **********************************/

// low level utilities
void systemrandpos(simptr sim,double *pos);
double systemvolume(simptr sim);
void systemcorners(simptr sim,double *poslo,double *poshi);
double systemdiagonal(simptr sim);
int posinsystem(simptr sim,double *pos);

// memory management
wallptr wallalloc(void);
void wallfree(wallptr wptr);
wallptr *wallsalloc(int dim);
void wallsfree(wallptr *wlist,int dim);

// data structure output
void walloutput(simptr sim);
void writewalls(simptr sim,FILE *fptr);
int checkwallparams(simptr sim,int *warnptr);

// structure setup
int walladd(simptr sim,int d,int highside,double pos,char type);

// core simulation functions
int checkwalls_threaded(simptr sim,int ll,int reborn,boxptr bptr);//?? change
int checkwalls(simptr sim,int ll,int reborn,boxptr bptr);//?? change

/********************************* Reactions ********************************/

// enumerated types
enum RevParam rxnstring2rp(char *string);
char *rxnrp2string(enum RevParam rp,char *string);

// low level utilities
int readrxnname(simptr sim,char *rname,int *orderptr,rxnptr *rxnpt);
int rxnpackident(int order,int maxspecies,int *ident);
void rxnunpackident(int order,int maxspecies,int ipack,int *ident);
enum MolecState rxnpackstate(int order,enum MolecState *mstate);
void rxnunpackstate(int order,enum MolecState mspack,enum MolecState *mstate);
int rxnreactantstate(rxnptr rxn,enum MolecState *mstate,int convertb2f);
int rxnallstates(rxnptr rxn);
int findreverserxn(simptr sim,int order,int r,int *optr,int *rptr);
int rxnisprod(simptr sim,int i,enum MolecState ms,int code);

// memory management
rxnptr rxnalloc(int order);
void rxnfree(rxnptr rxn);
rxnssptr rxnssalloc(int order,int maxspecies);
void rxnssfree(rxnssptr rxnss);

// data structure output
void rxnoutput(simptr sim,int order);
void writereactions(simptr sim,FILE *fptr);
int checkrxnparams(simptr sim,int *warnptr);

// parameter calculations
int rxnsetrate(simptr sim,int order,int r,char *erstr);
int rxnsetrates(simptr sim,int order,char *erstr);
int rxnsetproduct(simptr sim,int order,int r,char *erstr);
int rxnsetproducts(simptr sim,int order,char *erstr);
double rxncalcrate(simptr sim,int order,int r,double *pgemptr);
void rxncalctau(simptr sim,int order);
int rxnsettimestep(simptr sim);

// structure set up
void rxnsetcondition(simptr sim,int order,enum StructCond cond,int upgrade);
int rxnsetmollist(simptr sim,int order);
int RxnSetValue(simptr sim,char *option,rxnptr rxn,double value);
int RxnSetRevparam(simptr sim,rxnptr rxn,enum RevParam rparamt,double rparam,int prd,double *pos,int dim);
void RxnSetPermit(simptr sim,rxnptr rxn,int order,enum MolecState *rctstate,int value);
rxnptr RxnAddReaction(simptr sim,char *rname,int order,int *rctident,enum MolecState *rctstate,int nprod,int *prdident,enum MolecState *prdstate,compartptr cmpt,surfaceptr srf);
rxnptr RxnAddReactionCheck(simptr sim,char *rname,int order,int *rctident,enum MolecState *rctstate,int nprod,int *prdident,enum MolecState *prdstate,compartptr cmpt,surfaceptr srf,char *erstr);
int loadrxn(simptr sim,ParseFilePtr *pfpptr,char *line2,char *erstr);
int setuprxns(simptr sim);

// core simulation functions
int doreact(simptr sim,rxnptr rxn,moleculeptr mptr1,moleculeptr mptr2,int ll1,int m1,int ll2,int m2,double *pos,panelptr pnl);
int zeroreact(simptr sim);
int unireact(simptr sim);
int unireact_threaded(simptr sim);//??????? change
int morebireact(simptr sim,rxnptr rxn,moleculeptr mptr1,moleculeptr mptr2,int ll1,int m1,int ll2,enum EventType et);
int bireact(simptr sim,int neigh);
int bireact_threaded(simptr sim,int neigh);//???? change
int bireact_threaded_intrabox(simptr sim);//????? change
int bireact_threaded_interbox(simptr sim);//????? change

void* check_for_intrabox_bireactions_threaded(void* data);//????? change

/********************************* Surfaces *********************************/

// enumerated types
enum PanelFace surfstring2face(char *string);
char *surfface2string(enum PanelFace face,char *string);
enum SrfAction surfstring2act(char *string);
char *surfact2string(enum SrfAction act,char *string);
enum PanelShape surfstring2ps(char *string);
char *surfps2string(enum PanelShape ps,char *string);
enum DrawMode surfstring2dm(char *string);
char *surfdm2string(enum DrawMode dm,char *string);

// low level utilities
int readsurfacename(simptr sim,char *str,enum PanelShape *psptr,int *pptr);
int panelpoints(enum PanelShape ps,int dim);
int surfpanelparams(enum PanelShape ps,int dim);
void panelmiddle(panelptr pnl,double *middle,int dim,int onpanel);
double panelarea(panelptr pnl,int dim);
double surfacearea(surfaceptr srf,int dim,int *totpanelptr);
double surfacearea2(simptr sim,int surface,enum PanelShape ps,char *pname,int *totpanelptr);
void panelrandpos(panelptr pnl,double *pos,int dim);
panelptr surfrandpos(surfaceptr srf,double *pos,int dim);
int issurfprod(simptr sim,int i,enum MolecState ms);
int srfsamestate(enum MolecState ms1,enum PanelFace face1,enum MolecState ms2,enum MolecState *ms3ptr);
void srfreverseaction(enum MolecState ms1,enum PanelFace face1,enum MolecState ms2,enum MolecState *ms3ptr,enum PanelFace *face2ptr,enum MolecState *ms4ptr);
void srftristate2index(enum MolecState ms,enum MolecState ms1,enum MolecState ms2,enum MolecState *ms3ptr,enum PanelFace *faceptr,enum MolecState *ms4ptr);
void srfindex2tristate(enum MolecState ms3,enum PanelFace face,enum MolecState ms4,enum MolecState *msptr,enum MolecState *ms1ptr,enum MolecState *ms2ptr);

// memory management
surfactionptr surfaceactionalloc(int species);
void surfaceactionfree(surfactionptr actdetails);
int panelsalloc(surfaceptr srf,int dim,int maxpanel,int maxspecies,enum PanelShape ps);
void panelfree(panelptr pnl);
int emittersalloc(surfaceptr srf,enum PanelFace face,int oldmaxspecies,int maxspecies);
surfaceptr surfacealloc(surfaceptr srf,int oldmaxspecies,int maxspecies,int dim);
void surfacefree(surfaceptr srf,int maxspecies);
surfacessptr surfacessalloc(surfacessptr srfss,int maxsurface,int maxspecies,int dim);
void surfacessfree(surfacessptr srfss);

// data structure output
void surfaceoutput(simptr sim);
void writesurfaces(simptr sim,FILE *fptr);
int checksurfaceparams(simptr sim,int *warnptr);

// structure set up
int surfenablesurfaces(simptr sim,int maxsurf);
surfaceptr surfaddsurface(simptr sim,char *surfname);
void surfsetcondition(surfacessptr surfss,enum StructCond cond,int upgrade);
int surfsetepsilon(simptr sim,double epsilon);
int surfsetneighdist(simptr sim,double neighdist);
int surfsetcolor(surfaceptr srf,enum PanelFace face,double *rgba);
int surfsetedgepts(surfaceptr srf,double value);
int surfsetstipple(surfaceptr srf,unsigned int factor,unsigned int pattern);
int surfsetdrawmode(surfaceptr srf,enum PanelFace face,enum DrawMode dm);
int surfsetshiny(surfaceptr srf,enum PanelFace face,double shiny);
int surfsetaction(surfaceptr srf,int i,enum MolecState ms,enum PanelFace face,enum SrfAction act);
int surfsetrate(surfaceptr srf,int ident,enum MolecState ms,enum MolecState ms1,enum MolecState ms2,int newident,double value,int which);
int surfsetmaxpanel(surfaceptr srf,int dim,enum PanelShape ps,int maxpanel);
int surfaddpanel(surfaceptr srf,int dim,enum PanelShape ps,char *string,double *params,char *name);
int surfsetemitterabsorption(simptr sim);
int surfsetjumppanel(surfaceptr srf,panelptr pnl1,enum PanelFace face1,int bidirect,panelptr pnl2,enum PanelFace face2);
double srfcalcrate(simptr sim,surfaceptr srf,int i,enum MolecState ms1,enum PanelFace face,enum MolecState ms2);
double srfcalcprob(simptr sim,surfaceptr srf,int i,enum MolecState ms1,enum PanelFace face,enum MolecState ms2);
int surfsetneighbors(panelptr pnl,panelptr *neighlist,int nneigh,int add);
int surfaddemitter(surfaceptr srf,enum PanelFace face,int i,double amount,double *pos,int dim);
surfaceptr surfreadstring(simptr sim,surfaceptr srf,char *word,char *line2,char *erstr);
int loadsurface(simptr sim,ParseFilePtr *pfpptr,char *line2,char *erstr);
int surfupdateparams(simptr sim);
int surfupdatelists(simptr sim);

// core simulation functions
enum PanelFace panelside(double* pt,panelptr pnl,int dim,double *distptr);
void panelnormal(panelptr pnl,double *pos,enum PanelFace face,int dim,double *norm);
int lineXpanel(double *pt1,double *pt2,panelptr pnl,int dim,double *crsspt,enum PanelFace *face1ptr,enum PanelFace *face2ptr,double *crossptr,double *cross2ptr,int *veryclose);
int ptinpanel(double *pt,panelptr pnl,int dim);
enum SrfAction surfaction(surfaceptr srf,enum PanelFace face,int ident,enum MolecState ms,int *i2ptr,enum MolecState *ms2ptr);
int rxnXsurface(simptr sim,moleculeptr mptr1,moleculeptr mptr2);
void fixpt2panel(double *pt,panelptr pnl,int dim,enum PanelFace face,double epsilon);
void movept2panel(double *pt,panelptr pnl,int dim);
double closestpanelpt(panelptr pnl,int dim,double *testpt,double *pnlpt);
void movemol2closepanel(simptr sim,moleculeptr mptr,int dim,double epsilon,double neighdist);
void surfacereflect(moleculeptr mptr,panelptr pnl,double *crsspt,int dim,enum PanelFace face);
int surfacejump(moleculeptr mptr,panelptr pnl,double *crsspt,enum PanelFace face,int dim);
int dosurfinteract(simptr sim,moleculeptr mptr,int ll,int m,panelptr pnl,enum PanelFace face,double *crsspt);
int checksurfaces(simptr sim,int ll,int reborn);
int checksurfacebound(simptr sim,int ll);

int checksurfaces_threaded(simptr sim,int ll,int reborn);

/*********************************** Boxes **********************************/

// low level utilities
void box2pos(simptr sim,boxptr bptr,double *poslo,double *poshi);
boxptr pos2box(simptr sim,double *pos);
void boxrandpos(simptr sim,double *pos,boxptr bptr);
int panelinbox(simptr sim,panelptr pnl,boxptr bptr);
int boxaddmol(moleculeptr mptr,int ll);
void boxremovemol(moleculeptr mptr,int ll);

// memory management
boxptr boxalloc(int dim,int nlist);
int expandbox(boxptr bptr,int n,int ll);
int expandboxpanels(boxptr bptr,int n);
void boxfree(boxptr bptr,int nlist);
boxptr *boxesalloc(int nbox,int dim,int nlist);
void boxesfree(boxptr *blist,int nbox,int nlist);
boxssptr boxssalloc(int dim);
void boxssfree(boxssptr boxs);

// data structure output
void boxoutput(boxssptr boxs,int blo,int bhi,int dim);
void boxssoutput(simptr sim);
int checkboxparams(simptr sim,int *warnptr);

// structure set up
void boxsetcondition(boxssptr boxs,enum StructCond cond,int upgrade);
int boxsetsize(simptr sim,char *info,double val);
int setupboxes(simptr sim);

// core simulation functions
boxptr line2nextbox(simptr sim,double *pt1,double *pt2,boxptr bptr);
int reassignmolecs(simptr sim,int diffusing,int reborn);

/******************************* Compartments *******************************/

// enumerated types
enum CmptLogic cmptstring2cl(char *string);
char *cmptcl2string(enum CmptLogic cls,char *string);

// low level utilities
int posincompart(simptr sim,double *pos,compartptr cmpt);
int compartrandpos(simptr sim,double *pos,compartptr cmpt);

// memory management
compartptr compartalloc(void);
void compartfree(compartptr cmpt);
compartssptr compartssalloc(int maxcmpt);
void compartssfree(compartssptr cmptss);

// data structure output
void compartoutput(simptr sim);
void writecomparts(simptr sim,FILE *fptr);
int checkcompartparams(simptr sim,int *warnptr);

// structure set up
void compartsetcondition(compartssptr cmptss,enum StructCond cond,int upgrade);
int compartaddsurf(compartptr cmpt,surfaceptr srf);
int compartaddpoint(compartptr cmpt,int dim,double *point);
int compartaddcmptl(compartptr cmpt,compartptr cmptl,enum CmptLogic sym);
int compartupdatebox(simptr sim,compartptr cmpt,boxptr bptr,double volfrac);
int cmptreadstring(simptr sim,int cmptindex,char *word,char *line2,char *erstr);
int loadcompart(simptr sim,ParseFilePtr *pfpptr,char *line2,char *erstr);
int setupcomparts(simptr sim);

/*********************************** Ports **********************************/

// memory management
portptr portalloc(void);
void portfree(portptr port);
portssptr portssalloc(int maxport);
void portssfree(portssptr portss);

// data structure output
void portoutput(simptr sim);
void writeports(simptr sim,FILE *fptr);
int checkportparams(simptr sim,int *warnptr);

// structure set up
void portsetcondition(portssptr portss,enum StructCond cond,int upgrade);
portptr addport(portssptr portss,char *portname,surfaceptr srf,enum PanelFace face);
int portreadstring(simptr sim,int portindex,char *word,char *line2,char *erstr);
int loadport(simptr sim,ParseFilePtr *pfpptr,char* line2,char *erstr);
int setupports(simptr sim);

// core simulation functions
int portgetmols(simptr sim,portptr port,int ident,enum MolecState ms);
int portputmols(simptr sim,portptr port,int nmol,int ident);
int porttransport(simptr sim1,portptr port1,simptr sim2,portptr port2);

/******************************** Moleculizer *******************************/

// low level utilities
int mzrTagName2SmolName(simptr sim,char *tagname);
int mzrSmolName2TagName(mzrssptr mzrss,char *smolname,char *tagname);
int mzrReadStreamName(char *str,char *streamname,enum MolecState *msptr);
int mzrGetSpeciesStreams(mzrssptr mzrss,char ***streamnames,int *numnames);
void mzrFreeSpeciesStreams(char **streamnames,int numnames);
int mzrIsTagNameInStream(mzrssptr mzrss,char *tagname,char *stream);

// memory management
int mzrallocrules(mzrssptr mzrss,int ruleschars);
int mzrallocstreams(mzrssptr mzrss,int maxstreams);
void mzrfreestreams(char **streamname,double **displaysize,double ***color,double **strmdifc,int maxstreams);
int mzrallocnamehash(mzrssptr mzrss,int maxnamehash);
void mzrfreenamehash(char **tagname,char **smolname,int maxnamehash);
int mzrallocrxnhash(mzrssptr mzrss,int maxrxnhash);
void mzrfreerxnhash(char **mzrrxn,char **smolrxn,int maxrxnhash);
int mzrallocdefaultstate(mzrssptr mzrss,int maxspecies);
mzrssptr mzrssalloc(void);
void mzrssfree(mzrssptr mzrss);

// data structure output
int mzrCheckParams(simptr sim,int *warnptr);
int mzrNumberOfSpecies(mzrssptr mzrss);
int mzrNumberOfReactions(mzrssptr mzrss);
void mzroutput(mzrssptr mzrss);
void mzrssoutput(simptr sim);
void mzrsswrite(simptr sim,FILE *fptr);

// structure set up
void mzrsetcondition(mzrssptr mzrss,enum StructCond cond,int upgrade);
int mzrAssignDrawingParameters(simptr sim,char *tagname,int ident);
int mzrAssignDiffCoeff(simptr sim,char *tagname,double mass,int ident);
int mzrSetDefaultState(simptr sim,int ident,enum MolecState ms);
int mzrAssignProductDefaultState(mzrssptr mzrss,int *reactants,int nreactants,int *products,int nproducts);
int mzrSetStreamDisplay(mzrssptr mzrss,char *streamname,enum MolecState ms,double displaysize,double *color);
int mzrSetStreamDifc(mzrssptr mzrss,char *streamname,enum MolecState ms,double difc);
int mzraddtonamehash(mzrssptr mzrss,char *tagname,char *smolname);
int mzraddtorxnhash(mzrssptr mzrss,char *mzrrxn,char *smolrxn);
void mzrNextSmolrxnName(mzrssptr mzrss,char *smolrxn);
int mzrMakeNameHash(simptr sim);
int mzrssreadrules(simptr sim,ParseFilePtr *pfpptr,char *erstr);
int mzrssload(simptr sim,char *erstr);
void mzrSetValue(mzrssptr mzrss,char *item,int i1);
int mzrsetupmoleculizer(simptr sim,char *erstr);

// core simulation functions
int mzrExpandSpecies(simptr sim,int ident);
int mzrExpandNetwork(simptr sim);
int mzrExpandUnexpandedSpecies(simptr sim);
int mzrAddRxn(simptr sim,char *name,int order,int *reactants,int *products,int nprod,double rate);

/******************************** Threading *********************************/
//???????????? all of this section is new, and undocumented
int getnumberofthreads(simptr sim);
void setnumberofthreads(simptr sim, int newNumber);
void clearthreaddata( threadptr pthread);
stack* alloc_stack(); // Creates a new stack
void free_stack(stack* pStack); // Frees the stack
void push_data_onto_stack(stack* pStack, void* data, size_t data_size);
void clear_stack(stack* pStack);
threadssptr alloc_threadss();
int calculatestride(int total_number, int number_threads);

/********************************* Graphics *********************************/

// enumerated types
enum LightParam graphicsstring2lp(char *string);
char *graphicslp2string(enum LightParam lp,char *string);

// low level utilities
int graphicsreadcolor(char **stringptr,double *rgba);

// memory management
graphicsssptr graphssalloc(void);
void graphssfree(graphicsssptr graphss);

// data structure output
void graphssoutput(simptr sim);
void writegraphss(simptr sim,FILE *fptr);
int checkgraphicsparams(simptr sim,int *warnptr);

// structure setup
void graphicssetlight(graphicsssptr graphss,int lt,enum LightParam ltparam,double *value);

// core simulation functions
void RenderSurfaces(simptr sim);
void RenderMolecs(simptr sim);
void RenderSim(simptr sim);

/********************************* Commands *********************************/

enum CMDcode docommand(void *cmdfnarg,cmdptr cmd,char *line);
void cmdmeansqrdispfree(cmdptr cmd);

/******************************** Simulation ********************************/

// enumerated types
enum SmolStruct simstring2ss(char *string);
char *simss2string(enum SmolStruct ss,char *string);
char *simsc2string(enum StructCond sc,char *string);

// low level utilities
void Simsetrandseed(simptr sim,long int randseed);

// memory management
simptr simalloc(char *root);
void simfree(simptr sim);

// data structure output
void simoutput(simptr sim);
void writesim(simptr sim,FILE *fptr);
void checksimparams(simptr sim);

// structure set up
int simsetpthreads(simptr sim,int number);
void simsetcondition(simptr sim,enum StructCond cond,int upgrade);
int simsetdim(simptr sim,int dim);
int simsettime(simptr sim,double time,int code);
int simreadstring(simptr sim,char *word,char *line2,char *erstr);
int loadsim(simptr sim,char *fileroot,char *filename,char *erstr,char *flags);
int simupdate(simptr sim,char *erstr);
int setupsim(char *root,char *filename,simptr *smptr,char *flags);

// core simulation functions
int simdocommands(simptr sim);
int simulatetimestep(simptr sim);
void endsimulate(simptr sim,int er);
int smolsimulate(simptr sim);

/********************************* Threads **********************************/
//???????????? all of this section is new, and undocumented
void threadssfree(threadssptr threads);

void* checksurfaces_threaded_helper(void* data);
void* check_for_reactions_threaded(void* data);

int checksurfaces(simptr sim,int ll,int reborn);

typedef struct surface_data_struct {
	simptr sim;
	int live_list_ndx;
	int firstNdx;
	int secondNdx;
	int resurrect_only;
	} *ptrsurfacefuncdata;

#endif

